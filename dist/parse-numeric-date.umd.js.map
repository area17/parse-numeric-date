{"version":3,"file":"parse-numeric-date.umd.js","sources":["../src/index.js"],"sourcesContent":["let locale = new Intl.NumberFormat().resolvedOptions().locale;\nconst today = new Date().setHours(0, 0, 0, 0);\nconst thisYear = new Date(today).getFullYear();\nconst yearInMs = 365.25 * 24 * 60 * 60 * 1000;\nconst twoYearsInMs = yearInMs * 2;\nconst hundredYearsInMs = yearInMs * 100;\nconst getLocaleOrder = () => {\n  const dateStr = new Date(2000, 11, 13).toLocaleDateString(locale);\n  const parts = [\n    { name: 'd', index: dateStr.indexOf('13') },\n    { name: 'm', index: dateStr.indexOf('12') },\n    { name: 'y', index: dateStr.indexOf('2000') },\n  ].sort((a, b) => a.index - b.index);\n  return parts.map(item => item.name).join('-');\n};\n\nlet localeOrder = getLocaleOrder();\n\n// Month in JavaScript is 0-indexed (January is 0, February is 1, etc),\n// but by using 0 as the day it will give us the last day of the prior\n// month. So passing in 1 as the month number will return the last day\n// of January, not February\nconst daysInMonth = (m, y) => {\n  return new Date(y, m, 0).getDate();\n};\n\nconst make4DigitYear = (y) => {\n  if (y.length === 2) {\n    let twoDigitCutoffYear = 50;\n    let century = Math.floor(thisYear / 1000) * 1000;\n    let year = century + parseInt(y, 10);\n    let diff = Math.abs(year - (thisYear + twoDigitCutoffYear));\n    return (year < thisYear + twoDigitCutoffYear) || diff > 100 ? year : year - 100;\n  }\n  return y;\n}\n\n/*\n    persianToGregorian,\n    adapted from: https://stackoverflow.com/questions/71421825/how-to-convert-persian-jalali-dates-to-other-18-calendar-dates-in-javascript-w\n\n    credit to Mohsen Alyafei\n    https://github.com/MohsenAlyafei\n    https://twitter.com/maalyafei\n*/\nfunction persianToGregorian(year, month, day) {\n  year = parseInt(year, 10);\n  month = parseInt(month, 10);\n  day = parseInt(day, 10);\n\n  const dFormat = new Intl.DateTimeFormat('en-u-ca-persian',{\n    dateStyle:'short',\n    timeZone:'UTC'\n  });\n\n  let gregorianDate = new Date(Date.UTC(2000,month,day));\n\n  gregorianDate = new Date(gregorianDate.setUTCDate(gregorianDate.getUTCDate() + 226867));\n\n  const gregorianYear = gregorianDate.getUTCFullYear() - 2000 + year;\n  gregorianDate = new Date(\n    ((gregorianYear < 0) ? '-' : '+') +\n    ('00000' + Math.abs(gregorianYear)).slice(-6) +\n    '-' +\n    ('0' + (gregorianDate.getUTCMonth() + 1)).slice(-2) +\n    '-' +\n    ('0' + (gregorianDate.getUTCDate())).slice(-2)\n  );\n\n  let [pM, pD, pY] = [...dFormat.format(gregorianDate).split('/')]\n  let i = 0;\n\n  gregorianDate = new Date(\n    gregorianDate.setUTCDate(\n      gregorianDate.getUTCDate() +\n      Math.floor(\n        (year * 365.25) +\n        (month * 30.44) +\n        day -\n        (\n          (pY.split(' ')[0] * 365.25) +\n          (pM * 30.44) +\n          (pD*1)\n        )\n      ) - 2\n    )\n  );\n\n  while (i < 4) {\n    [pM, pD, pY] = [...dFormat.format(gregorianDate).split('/')];\n    if (parseInt(pD, 10) === day && parseInt(pM , 10) === month && parseInt(pY.split(' ')[0], 10) === year) {\n      return gregorianDate;\n    }\n    gregorianDate = new Date(gregorianDate.setUTCDate(gregorianDate.getUTCDate() + 1));\n    i++;\n  }\n  console.log('Invalid Persian date');\n  throw new Error('Invalid Persian date');\n}\n\nconst getDatePart = (dateStr, format, part) => {\n    return dateStr.substring(format.indexOf(part), format.indexOf(part) + (format.match(new RegExp(part, 'g')) || []).length);\n};\n\nconst splitDateString = (dateStr, format) => {\n    const parts = [\n      { name: 'd', index: format.indexOf('D') },\n      { name: 'm', index: format.indexOf('M') },\n      { name: 'y', index: format.indexOf('Y') },\n    ].sort((a, b) => a.index - b.index);\n\n    return {\n        y: getDatePart(dateStr, format, 'Y'),\n        m: getDatePart(dateStr, format, 'M'),\n        d: getDatePart(dateStr, format, 'D'),\n        order: parts.map(item => item.name).join('-'),\n    }\n};\n\nconst splitDates = (dateStr, formats) => {\n    return formats.map(format => splitDateString(dateStr, format));\n};\n\nconst generateDate = (y, m, d) => {\n  // if year is 2 digits, guess 19XX or 20XX\n  y = make4DigitYear(y);\n\n  // convert to numbers\n  y = parseInt(y, 10);\n  m = parseInt(m, 10);\n  d = parseInt(d, 10);\n\n  // stop months being over 12\n  m = m > 12 ? null : m;\n\n  // stop day being over how many days are in the month\n  d = d > daysInMonth(m, y) ? null : d;\n\n  // pad month and day\n  m = m < 10 ? `0${m}` : m;\n  d = d < 10 ? `0${d}` : d;\n\n  // test date\n  let t = new Date(`${y}-${m}-${d}T00:00:00.000+00:00`);\n\n  if (t instanceof Date && !isNaN(t)) {\n    return t;\n  } else {\n    return null;\n  }\n};\n\nconst getMostProbableDate = (dates, dateStr) => {\n  // make date strs, set order score\n  // filter out nulls\n  // order by score\n  dates = dates\n    .map(obj => {\n      // make date\n      obj.d = generateDate(obj.y, obj.m, obj.d);\n      // make year a number\n      obj.y = parseInt(make4DigitYear(obj.y), 10);\n      // find how far away from this year the date is\n      //obj.diff = Math.abs(new Date(today).getFullYear() - obj.y);\n      obj.diff = Math.abs(today - obj.d);\n      // if the date is in locale order, give it a higher score\n      obj.score = localeOrder === obj.order ? 2 : 1;\n      //\n      // Assumption: dates closer to today are better\n      // Why: date pickers for hotels, restaurants, events tend to\n      // happen this year or next year. Dates of birth tend to happen\n      // from now to 100 years in the past. Retirement ages, mortgage\n      // completions tend to happen from now to 100 years in the future\n      //\n      // if the year difference is larger than 100, its probably useless\n      // eg: a 29 made it 2922 rather than 29th of a month, 2022\n      if (obj.diff > hundredYearsInMs) {\n        obj.score--;\n      }\n      // year is really quite close to this year, probably more likely\n      if (obj.diff < twoYearsInMs) {\n        obj.score++;\n      }\n\n      return obj;\n    })\n    // remove any null dates from invalid dates being made\n    .filter(obj => obj.d !== null)\n    // sort by score, high to low\n    .sort((a, b) => {\n      return b.score - a.score;\n    });\n\n  // whats our highest score?\n  const highestScore = dates.length ? dates[0].score : 0;\n\n  // remove anything that hasn't got the lowest score\n  // get just the dates\n  // order by closest to today\n  dates = dates\n    // remove anything that doesn't match our high score\n    .filter(obj => obj.score === highestScore)\n    // sort by year distance, low to high\n    .sort((a, b) => {\n      return a.diff - b.diff;\n    })\n    .map(obj => obj.d);\n\n  // return first date (highest score, lowest year difference)\n  if (dates.length) {\n    return dates[0];\n  }\n  return null;\n};\n\nconst parseNumericDate = (dateStr, options) => {\n  if (options?.locale) {\n    locale = options.locale;\n    localeOrder = getLocaleOrder();\n  }\n\n  let originalDateStr = dateStr;\n  dateStr = dateStr.replace(/[۰-۹]/g, d => '۰۱۲۳۴۵۶۷۸۹'.indexOf(d))\n    .replace(/[٠-٩]/g, d => '٠١٢٣٤٥٦٧٨٩'.indexOf(d)).trim();\n  let dates = [];\n\n  // input probably = ISO YYYY-MM-DD or YYYY-M-D\n  let matches = [\n    ...dateStr.matchAll(/([0-9]{4})[^0-9]{1,}([0-9]{1,2})[^0-9]{1,}([0-9]{1,2})/g)\n  ];\n  if (matches.length > 0) {\n    if (originalDateStr.match(/[۰-۹]/g)) {\n        return persianToGregorian(matches[0][1], matches[0][2], matches[0][3]);\n    } else {\n        return generateDate(matches[0][1], matches[0][2], matches[0][3]);\n    }\n  }\n\n  // input doesn't follow ISO YYYY-MM-DD\n  // lets check for DD-MM-YYYY (or MM-DD-YYYY)\n  matches = [\n    ...dateStr.matchAll(/([0-9]{1,2})[^0-9]{1,}([0-9]{2})[^0-9]{1,}([0-9]{4})/g)\n  ];\n  if (matches.length > 0) {\n    dates.push({\n      y: matches[0][3],\n      m: matches[0][2],\n      d: matches[0][1],\n      order: 'd-m-y'\n    });\n\n    dates.push({\n      y: matches[0][3],\n      m: matches[0][1],\n      d: matches[0][2],\n      order: 'm-d-y'\n    });\n    //\n    return getMostProbableDate(dates, dateStr);\n  }\n\n  // lets check for DD-MM-YY (or MM-DD-YY), YY-MM-DD\n  // and D-M-YY, M-DD-YY\n  matches = [\n    ...dateStr.matchAll(\n      /([0-9]{1,2})[^0-9]{1,}([0-9]{1,2})[^0-9]{1,}([0-9]{1,2})/g\n    )\n  ];\n  if (matches.length > 0) {\n    dates.push({\n      y: matches[0][3],\n      m: matches[0][2],\n      d: matches[0][1],\n      order: 'd-m-y'\n    });\n\n    dates.push({\n      y: matches[0][3],\n      m: matches[0][1],\n      d: matches[0][2],\n      order: 'm-d-y'\n    });\n\n    dates.push({\n      y: matches[0][1],\n      m: matches[0][2],\n      d: matches[0][3],\n      order: 'y-m-d'\n    });\n    //\n    return getMostProbableDate(dates, originalDateStr);\n  }\n\n  // input has no spaces between dates\n  // very much guessing now\n\n  matches = [\n    ...dateStr.matchAll(\n      /[0-9]{1,}/g\n    )\n  ];\n  if (matches.length > 0) {\n      // could be YYYYMMDD, DDMMYYYY, MMDDYYYY\n      if (dateStr.length === 8) {\n        dates = splitDates(dateStr, ['YYYYMMDD', 'DDMMYYYY', 'MMDDYYYY']);\n      }\n\n      // could be YYYYMMD, YYYYMDD,\n      // or DDMYYYY, MDDYYYY, DMMYYYY, MMDYYYY\n      if (dateStr.length === 7) {\n        dates = splitDates(dateStr, ['YYYYMMD', 'YYYYMDD', 'DDMYYYY', 'MDDYYYY', 'DMMYYYY', 'MMDYYYY']);\n      }\n\n      // or could be YYMMDD, DDMMYY, MMDDYY\n      // or worse, could be YYYYMD, DMYYYY, MDYYYY\n      if (dateStr.length === 6) {\n        dates = splitDates(dateStr, ['YYMMDD', 'DDMMYY', 'MMDDYY', 'YYYYMD', 'DMYYYY', 'MDYYYY']);\n      }\n\n      // could be YYMMD, YYMDD,\n      // or DDMYY, MDDYY, DMMYY, MMDYY\n      if (dateStr.length === 5) {\n        dates = splitDates(dateStr, ['YYMMD', 'YYMDD', 'DDMYY', 'MDDYY', 'DMMYY', 'MMDYY']);\n      }\n\n      // could be YYMD, DMYY, MDYY\n      if (dateStr.length === 4) {\n        dates = splitDates(dateStr, ['YYMD', 'DMYY', 'MDYY']);\n      }\n\n      //\n      return getMostProbableDate(dates, dateStr);\n   }\n\n   console.log('parseNumericDate - unknown format:', dateStr);\n   return null;\n};\n\nexport default parseNumericDate;\n"],"names":["locale","Intl","NumberFormat","resolvedOptions","today","Date","setHours","thisYear","getFullYear","getLocaleOrder","dateStr","toLocaleDateString","name","index","indexOf","sort","a","b","map","item","join","localeOrder","make4DigitYear","y","length","year","Math","floor","parseInt","diff","abs","format","part","substring","match","RegExp","splitDates","formats","parts","getDatePart","m","d","order","splitDateString","generateDate","getDate","daysInMonth","t","isNaN","getMostProbableDate","dates","highestScore","obj","score","yearInMs","filter","options","replace","trim","matches","concat","matchAll","originalDateStr","month","day","dFormat","DateTimeFormat","dateStyle","timeZone","gregorianDate","UTC","gregorianYear","setUTCDate","getUTCDate","getUTCFullYear","slice","getUTCMonth","split","pM","pD","pY","_ref","i","_ref2","console","log","Error","persianToGregorian","push"],"mappings":"mOAAA,IAAIA,GAAS,IAAQC,KAACC,cAAeC,kBAAkBH,OACjDI,GAAQ,IAAQC,MAAGC,SAAS,EAAG,EAAG,EAAG,GACrCC,EAAW,IAAIF,KAAKD,GAAOI,cAIbC,EAAG,WACrB,IAAaC,EAAG,IAAIL,KAAK,IAAM,GAAI,IAAIM,mBAAmBX,GAM1D,MALc,CACZ,CAAEY,KAAM,IAAKC,MAAOH,EAAQI,QAAQ,OACpC,CAAEF,KAAM,IAAKC,MAAOH,EAAQI,QAAQ,OACpC,CAAEF,KAAM,IAAKC,MAAOH,EAAQI,QAAQ,UACpCC,KAAK,SAACC,EAAGC,GAAC,SAAOJ,MAAQI,EAAEJ,KAAK,GACrBK,IAAI,SAAAC,GAAI,OAAQA,EAACP,IAAI,GAAEQ,KAAK,IAC3C,EAEeC,EAAGZ,IAUEa,EAAG,SAACC,GACtB,GAAiB,IAAbA,EAAEC,OAAc,CAClB,IAEQC,EADoC,IAA9BC,KAAKC,MAAMpB,EAAW,KACfqB,SAASL,EAAG,IACzBM,EAAGH,KAAKI,IAAIL,GAAQlB,EAHH,KAIzB,OAAQkB,EAAOlB,EAJU,IAIwBsB,EAAO,IAAMJ,EAAOA,EAAO,GAC9E,CACA,QACF,IAiEoB,SAACf,EAASqB,EAAQC,GAClC,OAAOtB,EAAQuB,UAAUF,EAAOjB,QAAQkB,GAAOD,EAAOjB,QAAQkB,IAASD,EAAOG,MAAM,IAAUC,OAACH,EAAM,OAAS,IAAIR,OACtH,EAiBgBY,EAAG,SAAC1B,EAAS2B,GACzB,OAAcA,EAACnB,IAAI,SAAAa,GAAM,OAhBL,SAACrB,EAASqB,GAC9B,IAAMO,EAAQ,CACZ,CAAE1B,KAAM,IAAKC,MAAOkB,EAAOjB,QAAQ,MACnC,CAAEF,KAAM,IAAKC,MAAOkB,EAAOjB,QAAQ,MACnC,CAAEF,KAAM,IAAKC,MAAOkB,EAAOjB,QAAQ,OACnCC,KAAK,SAACC,EAAGC,GAAMD,OAAAA,EAAEH,MAAQI,EAAEJ,KAAK,GAElC,MAAO,CACHU,EAAGgB,EAAY7B,EAASqB,EAAQ,KAChCS,EAAGD,EAAY7B,EAASqB,EAAQ,KAChCU,EAAGF,EAAY7B,EAASqB,EAAQ,KAChCW,MAAOJ,EAAMpB,IAAI,SAAAC,GAAQA,OAAAA,EAAKP,IAAI,GAAEQ,KAAK,KAEjD,CAGgDuB,CAACjC,EAASqB,EAAO,EACjE,EAEkBa,EAAG,SAACrB,EAAGiB,EAAGC,GAE1BlB,EAAID,EAAeC,GAGnBA,EAAIK,SAASL,EAAG,IAChBiB,EAAIZ,SAASY,EAAG,IAOhBC,GANAA,EAAIb,SAASa,EAAG,KA5GE,SAACD,EAAGjB,GACtB,OAAO,IAAQlB,KAACkB,EAAGiB,EAAG,GAAGK,SAC3B,CAgHUC,CAHRN,EAAIA,EAAI,GAAK,KAAOA,EAGGjB,GAAK,KAAOkB,EAGnCD,EAAIA,EAAI,GAAE,IAAOA,EAAMA,EACvBC,EAAIA,EAAI,GAAE,IAAOA,EAAMA,EAGvB,IAAKM,EAAG,IAAI1C,KAAQkB,MAAKiB,EAAC,IAAIC,EAAC,uBAE/B,OAAIM,aAAa1C,OAAS2C,MAAMD,GAEhCA,EAEA,IACF,EAEyBE,EAAG,SAACC,EAAOxC,GA0ClC,IAAMyC,GAtCND,EAAQA,EACLhC,IAAI,SAAAkC,GA2BH,OAzBAA,EAAIX,EAAIG,EAAaQ,EAAI7B,EAAG6B,EAAIZ,EAAGY,EAAIX,GAEvCW,EAAI7B,EAAIK,SAASN,EAAe8B,EAAI7B,GAAI,IAGxC6B,EAAIvB,KAAOH,KAAKI,IAAI1B,EAAQgD,EAAIX,GAEhCW,EAAIC,MAAQhC,IAAgB+B,EAAIV,MAAQ,EAAI,EAUxCU,EAAIvB,KA3KWyB,UA4KjBF,EAAIC,QAGFD,EAAIvB,KAhLOyB,UAiLbF,EAAIC,QAGCD,CACT,GAECG,OAAO,SAAAH,UAAiB,OAAPA,EAACX,CAAU,GAE5B1B,KAAK,SAACC,EAAGC,GACR,OAAOA,EAAEoC,MAAQrC,EAAEqC,KACrB,IAGyB7B,OAAS0B,EAAM,GAAGG,MAAQ,EAerD,OAVAH,EAAQA,EAELK,OAAO,SAAAH,GAAOA,OAAAA,EAAIC,QAAUF,CAAY,GAExCpC,KAAK,SAACC,EAAGC,GACR,OAAOD,EAAEa,KAAOZ,EAAEY,IACpB,GACCX,IAAI,SAAAkC,GAAG,OAAOA,EAACX,CAAC,IAGTjB,OACI0B,EAAC,GAER,IACT,SAEyB,SAACxC,EAAS8C,GACtB,MAAPA,GAAAA,EAASxD,SACXA,EAASwD,EAAQxD,OACjBqB,EAAcZ,KAGhB,MAAsBC,EACtBA,EAAUA,EAAQ+C,QAAQ,SAAU,SAAAhB,SAAK,aAAa3B,QAAQ2B,EAAE,GAC7DgB,QAAQ,SAAU,SAAAhB,GAAK,MAAA,aAAa3B,QAAQ2B,EAAE,GAAEiB,OACnD,MAAY,GAGDC,EAAA,GAAAC,OACNlD,EAAQmD,SAAS,4DAEtB,OAAIF,EAAQnC,OAAS,EACfsC,EAAgB5B,MAAM,UA1L9B,SAA4BT,EAAMsC,EAAOC,GACvCvC,EAAOG,SAASH,EAAM,IACtBsC,EAAQnC,SAASmC,EAAO,IACxBC,EAAMpC,SAASoC,EAAK,IAEpB,IAAaC,EAAG,IAAQhE,KAACiE,eAAe,kBAAkB,CACxDC,UAAU,QACVC,SAAS,QAGMC,EAAG,IAAQhE,KAACA,KAAKiE,IAAI,IAAKP,EAAMC,IAI3CO,GAFNF,EAAgB,IAAIhE,KAAKgE,EAAcG,WAAWH,EAAcI,aAAe,UAE3CC,iBAAmB,IAAOjD,EAC9D4C,EAAgB,IAAIhE,MAChBkE,EAAgB,EAAK,IAAM,MAC5B,QAAU7C,KAAKI,IAAIyC,IAAgBI,OAAO,GAC3C,KACC,KAAON,EAAcO,cAAgB,IAAID,OAAO,GACjD,KACC,IAAON,EAAcI,cAAeE,OAAO,IAG9C,IAAuBV,EAAAA,GAAAA,OAAAA,EAAQlC,OAAOsC,GAAeQ,MAAM,MAAtDC,EAAIC,EAAAA,GAAAA,OAAIC,EAAEC,EAAA,GACXC,EAAI,EAkBR,IAhBAb,EAAgB,IAAIhE,KAClBgE,EAAcG,WACZH,EAAcI,aACd/C,KAAKC,MACK,OAAPF,EACQ,MAARsC,EACDC,GAEsB,OAAnBgB,EAAGH,MAAM,KAAK,GACT,MAALC,EACG,EAAHC,IAED,IAIDG,EAAI,GAAG,CAAA,IAAAC,EAAA,GAAAvB,OACOK,EAAQlC,OAAOsC,GAAeQ,MAAM,MACvD,GADCC,EAAIC,EAAAA,GAAAA,EAAIC,EAAAA,GAAAA,OACLpD,SAASmD,EAAI,MAAQf,GAAOpC,SAASkD,EAAK,MAAQf,GAASnC,SAASoD,EAAGH,MAAM,KAAK,GAAI,MAAQpD,EAChG,OAAO4C,EAETA,EAAgB,IAAIhE,KAAKgE,EAAcG,WAAWH,EAAcI,aAAe,IAC/ES,GACF,CAEA,MADAE,QAAQC,IAAI,4BACGC,MAAC,uBAClB,CAsIiCC,CAAC5B,EAAQ,GAAG,GAAIA,EAAQ,GAAG,GAAIA,EAAQ,GAAG,IAEhDf,EAACe,EAAQ,GAAG,GAAIA,EAAQ,GAAG,GAAIA,EAAQ,GAAG,KAMnEA,YACKjD,EAAQmD,SAAS,2DAEVrC,OAAS,GACnB0B,EAAMsC,KAAK,CACTjE,EAAGoC,EAAQ,GAAG,GACdnB,EAAGmB,EAAQ,GAAG,GACdlB,EAAGkB,EAAQ,GAAG,GACdjB,MAAO,UAGTQ,EAAMsC,KAAK,CACTjE,EAAGoC,EAAQ,GAAG,GACdnB,EAAGmB,EAAQ,GAAG,GACdlB,EAAGkB,EAAQ,GAAG,GACdjB,MAAO,UAGiBO,EAACC,KAK7BS,EAAO,GAAAC,OACFlD,EAAQmD,SACT,+DAGQrC,OAAS,GACnB0B,EAAMsC,KAAK,CACTjE,EAAGoC,EAAQ,GAAG,GACdnB,EAAGmB,EAAQ,GAAG,GACdlB,EAAGkB,EAAQ,GAAG,GACdjB,MAAO,UAGTQ,EAAMsC,KAAK,CACTjE,EAAGoC,EAAQ,GAAG,GACdnB,EAAGmB,EAAQ,GAAG,GACdlB,EAAGkB,EAAQ,GAAG,GACdjB,MAAO,UAGTQ,EAAMsC,KAAK,CACTjE,EAAGoC,EAAQ,GAAG,GACdnB,EAAGmB,EAAQ,GAAG,GACdlB,EAAGkB,EAAQ,GAAG,GACdjB,MAAO,UAGFO,EAAoBC,KAM7BS,EACKjD,GAAAA,OAAAA,EAAQmD,SACT,gBAGQrC,OAAS,GAEM,IAAnBd,EAAQc,SACV0B,EAAQd,EAAW1B,EAAS,CAAC,WAAY,WAAY,cAKhC,IAAnBA,EAAQc,SACV0B,EAAQd,EAAW1B,EAAS,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,aAK/D,IAAnBA,EAAQc,SACV0B,EAAQd,EAAW1B,EAAS,CAAC,SAAU,SAAU,SAAU,SAAU,SAAU,YAK1D,IAAnBA,EAAQc,SACV0B,EAAQd,EAAW1B,EAAS,CAAC,QAAS,QAAS,QAAS,QAAS,QAAS,WAIrD,IAAnBA,EAAQc,SACV0B,EAAQd,EAAW1B,EAAS,CAAC,OAAQ,OAAQ,UAIxCuC,EAAoBC,KAG9BkC,QAAQC,IAAI,qCAAsC3E,GAErD,KAAA"}